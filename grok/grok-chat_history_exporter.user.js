// ==UserScript==
// @name         Grok Chat History Exporter
// @name:el      Εξαγωγέας Ιστορικού Συνομιλιών Grok
// @namespace    https://github.com/CarpeNoctemXD/UserScripts
// @version      2.0.8
// @description  Export Grok chat conversations to Markdown format
// @description:el Εξαγωγή συνομιλιών Grok σε μορφή Markdown
// @author       CarpeNoctemXD
// @match        https://grok.com/*
// @grant        none
// @icon         https://www.google.com/s2/favicons?sz=64&domain=grok.com
// @updateURL    https://raw.githubusercontent.com/CarpeNoctemXD/UserScripts/refs/heads/main/grok/grok-chat_history_exporter.user.js
// @downloadURL  https://raw.githubusercontent.com/CarpeNoctemXD/UserScripts/refs/heads/main/grok/grok-chat_history_exporter.user.js
// @license      MIT
// ==/UserScript==


// Disclaimer: This script is generated by AI and may require adjustments to work correctly.

(function() {
    'use strict';

    // Core functionality
    const EXPORT_BUTTON_ID = 'export-chat';

    function getConversationElements() {
        return document.querySelectorAll('div.message-bubble');
    }

    function expandCollapsedSections() {
        document.querySelectorAll('details').forEach(details => {
            details.setAttribute('open', '');
        });

        document.querySelectorAll('button, [role="button"], [aria-expanded="false"]').forEach(button => {
            const text = button.textContent.toLowerCase() || button.getAttribute('aria-label')?.toLowerCase() || '';
            if (text.includes('show') || text.includes('expand') || text.includes('more') || text.includes('load') || text.includes('older')) {
                button.click();
                console.debug(`Clicked button: ${text}`);
            }
        });

        ['click', 'input', 'change', 'scroll', 'mouseover', 'wheel'].forEach(eventType => {
            const event = new Event(eventType, { bubbles: true });
            document.dispatchEvent(event);
            window.dispatchEvent(event);
        });
    }

    function htmlToMarkdown(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Remove unwanted artifact tags
        doc.querySelectorAll('xaiArtifact').forEach(artifact => {
            artifact.replaceWith(...artifact.childNodes);
        });

        // Handle inline .mdmarkdown content with very broad selectors
        const markdownSelectors = [
            'div[class*="markdown"]',
            'pre[class*="markdown"]',
            'div[data-type*="markdown"]',
            'pre[data-type*="markdown"]',
            'div[class*="mdmarkdown"]',
            'pre[class*="mdmarkdown"]',
            '[data-filetype*="markdown"]',
            '[data-content*="markdown"]',
            'div[class*="code-block"]',
            'pre[class*="code-block"]',
            'div[class*="content"]',
            'pre:not([class*="language-"])',
            'div[data-testid*="markdown"]',
            'pre[data-testid*="markdown"]'
        ].join(', ');
        const markdownElements = doc.querySelectorAll(markdownSelectors);
        console.debug(`Found ${markdownElements.length} markdown elements`);
        markdownElements.forEach((md, index) => {
            const markdownContent = md.textContent.trim();
            console.debug(`Markdown element ${index}: ${markdownContent.substring(0, 50)}...`);
            if (markdownContent) {
                md.replaceWith(document.createTextNode(`\n${markdownContent}\n`));
            }
        });

        // Fallback: capture unmatched potential markdown containers
        doc.querySelectorAll('div:not([class]), pre:not([class]), [class*="content"]:not([class*="markdown"])').forEach(el => {
            const text = el.textContent.trim();
            if (text && (text.includes('```') || text.includes('**') || text.includes('*') || text.includes('['))) {
                console.debug(`Fallback markdown detected: ${text.substring(0, 50)}...`);
                el.replaceWith(document.createTextNode(`\n${text}\n`));
            }
        });

        // Handle code blocks
        doc.querySelectorAll('pre').forEach(pre => {
            const codeType = pre.querySelector('div > div:first-child')?.textContent.trim() || '';
            const codeContent = pre.querySelector('div > div:nth-child(3) > code')?.textContent || pre.textContent;
            pre.replaceWith(document.createTextNode(`\n\`\`\`${codeType}\n${codeContent.trim()}\n\`\`\`\n`));
        });

        // Handle inline code
        doc.querySelectorAll('code:not(pre code)').forEach(code => {
            code.replaceWith(document.createTextNode(`\`${code.textContent}\``));
        });

        // Handle inline markdown (bold, italic, links)
        doc.querySelectorAll('strong, b').forEach(el => {
            el.replaceWith(document.createTextNode(`**${el.textContent}**`));
        });

        doc.querySelectorAll('em, i').forEach(el => {
            el.replaceWith(document.createTextNode(`*${el.textContent}*`));
        });

        doc.querySelectorAll('a').forEach(link => {
            const href = link.getAttribute('href') || '';
            const text = link.textContent.trim();
            link.replaceWith(document.createTextNode(`[${text}](${href})`));
        });

        // Handle lists
        doc.querySelectorAll('ul').forEach(ul => {
            const markdown = Array.from(ul.querySelectorAll(':scope > li'))
                .map(li => `- ${li.textContent.trim()}`)
                .join('\n');
            ul.replaceWith(document.createTextNode(`\n${markdown}\n`));
        });

        doc.querySelectorAll('ol').forEach(ol => {
            const markdown = Array.from(ol.querySelectorAll(':scope > li'))
                .map((li, index) => `${index + 1}. ${li.textContent.trim()}`)
                .join('\n');
            ol.replaceWith(document.createTextNode(`\n${markdown}\n`));
        });

        // Handle span elements with markdown-like classes
        doc.querySelectorAll('span').forEach(span => {
            const text = span.textContent.trim();
            if (span.classList.contains('code') || span.classList.contains('inline-code')) {
                span.replaceWith(document.createTextNode(`\`${text}\``));
            } else if (span.classList.contains('bold') || span.classList.contains('strong')) {
                span.replaceWith(document.createTextNode(`**${text}**`));
            } else if (span.classList.contains('italic') || span.classList.contains('emphasis')) {
                span.replaceWith(document.createTextNode(`*${text}*`));
            }
        });

        // Clean up and normalize text
        let markdown = doc.body.innerHTML
            .replace(/<[^>]*>/g, '')
            .replace(/&gt;/g, '>')
            .replace(/&lt;/g, '<')
            .replace(/&amp;/g, '&')
            .replace(/\n\s*\n/g, '\n\n')
            .replace(/ {2,}/g, ' ')
            .replace(/^\s+|\s+$/g, '');

        return markdown;
    }

    function downloadMarkdown(content) {
        const blob = new Blob([content], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');

        a.href = url;
        a.download = `grok-chat-${new Date().toISOString().split('T')[0]}.md`;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function scrollToTop() {
        const mainContent = document.querySelector('main') || document.body;
        let previousHeight = mainContent.scrollHeight;
        let sameHeightCount = 0;
        let maxAttempts = 12;
        let previousMessageCount = 0;

        while (sameHeightCount < 3 && maxAttempts > 0) {
            mainContent.scrollTo({ top: 0, behavior: 'smooth' });
            window.scrollTo({ top: 0, behavior: 'smooth' });
            ['scroll', 'wheel', 'mouseover'].forEach(eventType => {
                mainContent.dispatchEvent(new Event(eventType, { bubbles: true }));
                window.dispatchEvent(new Event(eventType, { bubbles: true }));
            });

            // Click "Load More" buttons
            document.querySelectorAll('button, [role="button"]').forEach(button => {
                const text = button.textContent.toLowerCase() || button.getAttribute('aria-label')?.toLowerCase() || '';
                if (text.includes('load more') || text.includes('more messages') || text.includes('older')) {
                    button.click();
                    console.debug(`Clicked load more button: ${text}`);
                }
            });

            await sleep(800);

            const currentHeight = mainContent.scrollHeight;
            const currentMessageCount = document.querySelectorAll('div.message-bubble').length;
            console.debug(`Scroll attempt: height=${currentHeight}, previous=${previousHeight}, sameCount=${sameHeightCount}, messages=${currentMessageCount}, attemptsLeft=${maxAttempts}`);
            if (currentHeight === previousHeight && currentMessageCount === previousMessageCount) {
                sameHeightCount++;
            } else {
                sameHeightCount = 0;
            }
            previousHeight = currentHeight;
            previousMessageCount = currentMessageCount;
            maxAttempts--;
        }
    }

    function observeDOM(callback) {
        const observer = new MutationObserver((mutations, obs) => {
            console.debug(`DOM mutation detected, rechecking content`);
            callback();
        });
        observer.observe(document.body, { childList: true, subtree: true, attributes: true });
        setTimeout(() => observer.disconnect(), 5000);
    }

    function createExportButton() {
        if (document.getElementById(EXPORT_BUTTON_ID)) return;

        const button = document.createElement('button');
        button.id = EXPORT_BUTTON_ID;
        button.textContent = 'Export Chat';

        // Set initial styles
        const defaultStyles = {
            position: 'fixed',
            top: '20px',
            right: '200px',
            zIndex: '10000',
            padding: '5px 10px',
            backgroundColor: '#000000', // Standby: Black
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '15px',
            transition: 'background-color 0.3s ease, transform 0.2s ease',
            transform: 'scale(1)'
        };
        Object.assign(button.style, defaultStyles);

        button.addEventListener('click', async () => {
            button.disabled = true;
            button.textContent = 'Loading all messages...';
            button.style.backgroundColor = '#1e90ff'; // Loading: Blue

            try {
                // Reset DOM state
                expandCollapsedSections();
                await scrollToTop();

                // Retry parsing for markdown content
                let elements = getConversationElements();
                let markdownElements = document.querySelectorAll([
                    'div[class*="markdown"]',
                    'pre[class*="markdown"]',
                    'div[data-type*="markdown"]',
                    'pre[data-type*="markdown"]',
                    'div[class*="mdmarkdown"]',
                    'pre[class*="mdmarkdown"]',
                    '[data-filetype*="markdown"]',
                    '[data-content*="markdown"]',
                    'div[class*="code-block"]',
                    'pre[class*="code-block"]',
                    'div[class*="content"]',
                    'pre:not([class*="language-"])',
                    'div[data-testid*="markdown"]',
                    'pre[data-testid*="markdown"]'
                ].join(', '));
                let retryCount = 0;
                const maxRetries = 3;
                let previousMessageCount = elements.length;

                while ((markdownElements.length === 0 || elements.length < previousMessageCount) && retryCount < maxRetries) {
                    console.debug(`Retry ${retryCount + 1}/${maxRetries}: markdowns=${markdownElements.length}, messages=${elements.length}`);
                    await sleep(800);
                    expandCollapsedSections();
                    await scrollToTop();
                    elements = getConversationElements();
                    markdownElements = document.querySelectorAll([
                        'div[class*="markdown"]',
                        'pre[class*="markdown"]',
                        'div[data-type*="markdown"]',
                        'pre[data-type*="markdown"]',
                        'div[class*="mdmarkdown"]',
                        'pre[class*="mdmarkdown"]',
                        '[data-filetype*="markdown"]',
                        '[data-content*="markdown"]',
                        'div[class*="code-block"]',
                        'pre[class*="code-block"]',
                        'div[class*="content"]',
                        'pre:not([class*="language-"])',
                        'div[data-testid*="markdown"]',
                        'pre[data-testid*="markdown"]'
                    ].join(', '));
                    retryCount++;
                }

                // Final DOM observation
                await new Promise(resolve => {
                    observeDOM(resolve);
                    setTimeout(resolve, 1000);
                });

                button.textContent = 'Processing...';
                button.style.backgroundColor = '#ffa500'; // Processing: Orange
                await sleep(300);

                elements = getConversationElements();
                if (elements.length === 0) {
                    console.error('No conversation elements found');
                    button.style.backgroundColor = '#ff0000'; // Error: Red
                    alert('No conversation content found');
                    return;
                }

                let markdown = '';
                console.debug(`Processing ${elements.length} conversation elements`);
                for (let i = 0; i < elements.length; i += 2) {
                    if (!elements[i + 1]) {
                        console.warn(`Missing Grok response for user message at index ${i}`);
                        break;
                    }

                    const userElement = elements[i];
                    const grokElement = elements[i + 1];

                    grokElement.querySelectorAll('details, [aria-expanded="false"]').forEach(el => {
                        if (el.tagName.toLowerCase() === 'details') {
                            el.setAttribute('open', '');
                        } else {
                            el.setAttribute('aria-expanded', 'true');
                        }
                    });

                    const userText = htmlToMarkdown(userElement.innerHTML);
                    const grokText = htmlToMarkdown(grokElement.innerHTML);

                    markdown += `\n# User\n${userText}\n\n# Grok\n${grokText}\n\n`;
                }

                if (!markdown) {
                    console.error('No markdown content generated');
                    button.style.backgroundColor = '#ff0000'; // Error: Red
                    alert('No conversation content found');
                    return;
                }

                console.debug(`Generated markdown length: ${markdown.length} characters (~${Math.round(markdown.length / 1024)}KB)`);
                button.textContent = 'Downloading...';
                button.style.backgroundColor = '#32cd32'; // Downloading: Green
                await sleep(200);
                downloadMarkdown(markdown);

                // Show "Download Complete" for 3 seconds
                button.textContent = 'Download Complete';
                button.style.backgroundColor = '#32cd32'; // Keep green
                await sleep(3000);

                // Reset to default state
                button.textContent = 'Export Chat';
                button.disabled = false;
                Object.assign(button.style, defaultStyles);
            } catch (error) {
                console.error('Export failed:', error);
                button.style.backgroundColor = '#ff0000'; // Error: Red
                alert(`Failed to export chat: ${error.message}`);

                // Reset to default state even on error
                await sleep(3000);
                button.textContent = 'Export Chat';
                button.disabled = false;
                Object.assign(button.style, defaultStyles);
            }
        });

        button.addEventListener('mouseover', () => {
            if (!button.disabled) {
                button.style.transform = 'scale(1.05)';
            }
        });

        button.addEventListener('mouseout', () => {
            button.style.transform = 'scale(1)';
        });

        document.body.appendChild(button);
    }

    try {
        createExportButton();
        setInterval(() => {
            if (!document.getElementById(EXPORT_BUTTON_ID)) {
                createExportButton();
            }
        }, 1000);
    } catch (error) {
        console.error('Initialization failed:', error);
    }
})();